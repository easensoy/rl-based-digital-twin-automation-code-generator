import logging
from datetime import datetime
from typing import Dict, Any

logger = logging.getLogger(__name__)

class PLCCodeGenerator:
    """Generate IEC 61499 compliant PLC code from trained RL models"""
    
    def __init__(self):
        self.template = self._load_plc_template()
        logger.info("PLC Code Generator initialized")
    
    def generate_code(self, policy: Dict, environment_config: Dict, performance_targets: Dict) -> str:
        """Generate optimized PLC code based on RL policy"""
        
        # Extract policy parameters
        epsilon = policy.get("epsilon", 0.01)
        training_steps = policy.get("training_steps", 0)
        
        # Generate function blocks
        safety_fb = self._generate_safety_function_block(performance_targets)
        control_fb = self._generate_control_function_block(environment_config)
        optimization_fb = self._generate_optimization_function_block(policy)
        
        # Generate main program
        main_program = self._generate_main_program(environment_config, performance_targets)
        
        # Combine all code sections
        plc_code = f"""
{self._generate_header(policy, performance_targets)}

{safety_fb}

{control_fb}

{optimization_fb}

{main_program}

{self._generate_footer()}
"""
        
        logger.info(f"Generated PLC code with {len(plc_code)} characters")
        return plc_code
    
    def _load_plc_template(self) -> str:
        """Load base PLC code template"""
        return """
(* WMG Digital Twin Optimized Control System *)
(* Generated by RL-based optimization *)
(* University of Warwick - WMG Automation Systems Group *)
"""
    
    def _generate_header(self, policy: Dict, targets: Dict) -> str:
        """Generate PLC code header with metadata"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        return f"""
PROGRAM WMG_Optimized_Control
(* Generated: {timestamp} *)
(* Training Steps: {policy.get('training_steps', 0)} *)
(* Target Cycle Time: {targets.get('cycle_time', 30.0)}s *)
(* Target Throughput: {targets.get('throughput', 120.0)} units/min *)

VAR
    (* Process Variables *)
    cycle_time : REAL := 30.0;
    throughput : REAL := 0.0;
    safety_score : REAL := 1.0;
    energy_efficiency : REAL := 0.85;
    
    (* Control Variables *)
    speed_setpoint : REAL := 1.0;
    pressure_setpoint : REAL := 1.0;
    temperature_setpoint : REAL := 1.0;
    
    (* System State *)
    system_running : BOOL := FALSE;
    emergency_stop : BOOL := FALSE;
    maintenance_mode : BOOL := FALSE;
    
    (* Optimization Parameters *)
    learning_rate : REAL := 0.001;
    epsilon : REAL := {policy.get('epsilon', 0.01)};
    
    (* Performance Metrics *)
    production_count : DINT := 0;
    quality_index : REAL := 0.95;
    oee_value : REAL := 0.0;
END_VAR
"""
    
    def _generate_safety_function_block(self, targets: Dict) -> str:
        """Generate safety monitoring function block"""
        safety_threshold = targets.get('safety_threshold', 0.95)
        return f"""
FUNCTION_BLOCK FB_SafetyMonitor
VAR_INPUT
    temperature : REAL;
    pressure : REAL;
    vibration : REAL;
    emergency_button : BOOL;
END_VAR

VAR_OUTPUT
    safety_ok : BOOL;
    shutdown_required : BOOL;
    safety_score : REAL;
END_VAR

VAR
    temp_alarm : BOOL;
    pressure_alarm : BOOL;
    vibration_alarm : BOOL;
END_VAR

(* Safety Logic - RL Optimized Thresholds *)
temp_alarm := temperature > 80.0 OR temperature < -10.0;
pressure_alarm := pressure > 10.0 OR pressure < 0.1;
vibration_alarm := vibration > 5.0;

shutdown_required := temp_alarm OR pressure_alarm OR vibration_alarm OR emergency_button;
safety_ok := NOT shutdown_required;

(* Calculate Safety Score *)
IF safety_ok THEN
    safety_score := {safety_threshold};
ELSE
    safety_score := 0.0;
END_IF;

END_FUNCTION_BLOCK
"""
    
    def _generate_control_function_block(self, config: Dict) -> str:
        """Generate main control function block"""
        cycle_target = config.get('cycle_time_target', 30.0)
        return f"""
FUNCTION_BLOCK FB_ProcessControl
VAR_INPUT
    start_command : BOOL;
    stop_command : BOOL;
    speed_factor : REAL;
    pressure_factor : REAL;
    temp_factor : REAL;
END_VAR

VAR_OUTPUT
    motor_speed : REAL;
    valve_position : REAL;
    heater_power : REAL;
    process_active : BOOL;
END_VAR

VAR
    cycle_timer : TON;
    ramp_timer : TON;
END_VAR

(* RL-Optimized Process Control *)
IF start_command AND NOT stop_command THEN
    process_active := TRUE;
    
    (* Apply RL-learned speed optimization *)
    motor_speed := speed_factor * 100.0;
    
    (* Pressure control with learned parameters *)
    valve_position := pressure_factor * 90.0;
    
    (* Temperature control *)
    heater_power := temp_factor * 75.0;
    
    (* Cycle timing optimization *)
    cycle_timer(IN := process_active, PT := T#{cycle_target}s);
    
ELSE
    process_active := FALSE;
    motor_speed := 0.0;
    valve_position := 0.0;
    heater_power := 0.0;
    cycle_timer(IN := FALSE);
END_IF;

END_FUNCTION_BLOCK
"""
    
    def _generate_optimization_function_block(self, policy: Dict) -> str:
        """Generate RL optimization function block"""
        return f"""
FUNCTION_BLOCK FB_RLOptimizer
VAR_INPUT
    current_state : ARRAY[0..11] OF REAL;
    target_throughput : REAL;
    energy_target : REAL;
END_VAR

VAR_OUTPUT
    optimal_action : DINT;
    speed_recommendation : REAL;
    pressure_recommendation : REAL;
    temp_recommendation : REAL;
END_VAR

VAR
    state_normalized : ARRAY[0..11] OF REAL;
    q_values : ARRAY[0..5] OF REAL;
    best_action : DINT;
    i : DINT;
END_VAR

(* RL-based Action Selection *)
(* Normalize input states *)
FOR i := 0 TO 11 DO
    state_normalized[i] := current_state[i] / 2.0;  (* Clip to [-1,1] range *)
END_FOR;

(* Simplified Q-value approximation based on learned policy *)
(* Action 0: Conservative *)
q_values[0] := state_normalized[10] * 0.8 + state_normalized[11] * 0.5;

(* Action 1: Normal *)
q_values[1] := state_normalized[10] * 1.0 + state_normalized[11] * 0.7;

(* Action 2: Aggressive *)
q_values[2] := (1.0 - state_normalized[10]) * 0.6 + state_normalized[11] * 1.2;

(* Action 3: Energy Saving *)
q_values[3] := state_normalized[11] * (-0.8) + state_normalized[10] * 0.6;

(* Action 4: Quality Focus *)
q_values[4] := state_normalized[10] * 1.2 + state_normalized[11] * 0.4;

(* Action 5: Balanced *)
q_values[5] := (state_normalized[10] + state_normalized[11]) * 0.5;

(* Select best action *)
best_action := 0;
FOR i := 1 TO 5 DO
    IF q_values[i] > q_values[best_action] THEN
        best_action := i;
    END_IF;
END_FOR;

optimal_action := best_action;

(* Map action to control recommendations *)
CASE optimal_action OF
    0: (* Conservative *)
        speed_recommendation := 0.8;
        pressure_recommendation := 0.9;
        temp_recommendation := 0.85;
    1: (* Normal *)
        speed_recommendation := 1.0;
        pressure_recommendation := 1.0;
        temp_recommendation := 1.0;
    2: (* Aggressive *)
        speed_recommendation := 1.2;
        pressure_recommendation := 1.1;
        temp_recommendation := 1.1;
    3: (* Energy Saving *)
        speed_recommendation := 0.6;
        pressure_recommendation := 0.8;
        temp_recommendation := 0.8;
    4: (* Quality Focus *)
        speed_recommendation := 1.1;
        pressure_recommendation := 1.05;
        temp_recommendation := 0.95;
    5: (* Balanced *)
        speed_recommendation := 0.9;
        pressure_recommendation := 0.95;
        temp_recommendation := 0.9;
END_CASE;

END_FUNCTION_BLOCK
"""
    
    def _generate_main_program(self, config: Dict, targets: Dict) -> str:
        """Generate main program logic"""
        return f"""
(* Main Program Logic *)
VAR
    safety_monitor : FB_SafetyMonitor;
    process_control : FB_ProcessControl;
    rl_optimizer : FB_RLOptimizer;
    
    system_state : ARRAY[0..11] OF REAL;
    sensor_temp : REAL;
    sensor_pressure : REAL;
    sensor_vibration : REAL;
    
    start_btn : BOOL;
    stop_btn : BOOL;
    e_stop_btn : BOOL;
END_VAR

(* Read sensor inputs *)
(* sensor_temp := Analog_Input_1; *)
(* sensor_pressure := Analog_Input_2; *)
(* sensor_vibration := Analog_Input_3; *)

(* Safety monitoring *)
safety_monitor(
    temperature := sensor_temp,
    pressure := sensor_pressure,
    vibration := sensor_vibration,
    emergency_button := e_stop_btn
);

(* Update system state for RL *)
system_state[6] := sensor_temp / 100.0;  (* Normalize temperature *)
system_state[7] := sensor_pressure / 10.0;  (* Normalize pressure *)
system_state[8] := sensor_vibration / 5.0;  (* Normalize vibration *)

(* RL Optimization *)
rl_optimizer(
    current_state := system_state,
    target_throughput := {targets.get('throughput', 120.0)},
    energy_target := {targets.get('energy_efficiency_target', 0.85)}
);

(* Process Control *)
IF safety_monitor.safety_ok THEN
    process_control(
        start_command := start_btn,
        stop_command := stop_btn,
        speed_factor := rl_optimizer.speed_recommendation,
        pressure_factor := rl_optimizer.pressure_recommendation,
        temp_factor := rl_optimizer.temp_recommendation
    );
ELSE
    process_control(
        start_command := FALSE,
        stop_command := TRUE,
        speed_factor := 0.0,
        pressure_factor := 0.0,
        temp_factor := 0.0
    );
END_IF;

(* Calculate OEE *)
oee_value := safety_monitor.safety_score * (throughput / {targets.get('throughput', 120.0)}) * quality_index;

(* Update performance metrics *)
IF process_control.process_active THEN
    production_count := production_count + 1;
    throughput := production_count / cycle_time * 60.0;  (* Units per minute *)
END_IF;

END_PROGRAM
"""
    
    def _generate_footer(self) -> str:
        """Generate PLC code footer"""
        return f"""
(* End of WMG Optimized Control System *)
(* Generated by RL-based Digital Twin Platform *)
(* For technical support: wmg-automation@warwick.ac.uk *)
"""